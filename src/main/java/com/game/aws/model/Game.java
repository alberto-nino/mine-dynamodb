package com.game.aws.model;

import com.amazonaws.services.dynamodbv2.datamodeling.*;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperFieldModel.DynamoDBAttributeType;
import com.game.aws.enums.StatusEnum;
import com.game.aws.error.MineException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.*;
import java.util.stream.Stream;

@DynamoDBTable(tableName = "gameMines")
@Data
@AllArgsConstructor
@Builder
@NoArgsConstructor
public class Game {

    public static final String INVALID_REQUEST_COLUMNS_AND_ROWS= "Invalid move because the Columns, Rows and Bombs should be greater that 0";
    public static final String INVALID_REQUEST_BOMBS_LESS_CELLS= "Invalid move because. Amount of bombs should be less than total amount of cells";
    public static final String COULD_NOT_DO_MOVE= "You need the game is active ";
    public static final String REQUEST_CELL_IS_OUT= "You can't move because the cell is out of index";

    @DynamoDBAutoGeneratedKey
    @DynamoDBHashKey(attributeName = "id")
    private String id;

    @DynamoDBAttribute(attributeName = "userId")
    private String userId;

    @DynamoDBAttribute(attributeName = "data")
    private BackupData data;

    @DynamoDBAttribute(attributeName = "cells")
    private List<Cell> cells;

    @DynamoDBTyped(DynamoDBAttributeType.S)
    @DynamoDBAttribute(attributeName = "status")
    private StatusEnum status;

    @DynamoDBTyped(DynamoDBAttributeType.S)
    @DynamoDBAttribute(attributeName = "timeConsumed")
    @Builder.Default
    private long timePaused = 0L;

    @DynamoDBAttribute(attributeName = "creationTime")
    @DynamoDBAutoGeneratedTimestamp(strategy = DynamoDBAutoGenerateStrategy.CREATE)
    private Date creationTime;

    @DynamoDBAttribute(attributeName = "lastUpdate")
    @DynamoDBAutoGeneratedTimestamp(strategy = DynamoDBAutoGenerateStrategy.ALWAYS)
    private Date lastUpdate;


    public Game initCells(int columns, int rows, int bombs) {

        this.setData(BackupData.builder().rows(rows).columns(columns).bombs(bombs).build());

        if (columns <= 0 ||  rows <=0 || bombs<=0) {
            throw new MineException(INVALID_REQUEST_COLUMNS_AND_ROWS);
        }

        if (columns * rows <= bombs) {
            throw new MineException(INVALID_REQUEST_BOMBS_LESS_CELLS);
        }

        Set<Integer> bombDistribution = new HashSet<Integer>();
        while (bombDistribution.size() < bombs) {
            bombDistribution.add((int) (Math.random() * ((rows * columns) - 1)));
        }

        this.cells = new ArrayList<Cell>();
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < columns; c++) {
                cells.add(Cell.builder().positionX(r).positionY(c).bomb(bombDistribution.contains((r * rows) + c)).build());
            }
        }

        cells.forEach(cellToInit -> {
            int value = getAdjacentCellsStream(cellToInit).map(c -> c.isBomb() ? 1 : 0).reduce(0, Integer::sum);
            cellToInit.setValue(value);
        });

        return this;
    }

    public Stream<Cell> getAdjacentCellsStream(Cell cell) {
        return cells.stream().filter(c -> c.isAdjacentTo(cell));
    }

    public void pause() {
        if (!this.getStatus().equals(StatusEnum.GAME_PAUSED)) {
            acumulateTipoPaused();
        }
        this.setStatus(StatusEnum.GAME_PAUSED);
    }

    public void recognizeAdjacentCells(Cell aCell) {
        getAdjacentCellsStream(aCell).filter(adjCell -> !adjCell.isRecognized() && !adjCell.isBomb())
                .forEach(adjEmptyCell -> {
                    adjEmptyCell.setRecognized(true);
                    if (adjEmptyCell.getValue() == 0) {
                        recognizeAdjacentCells(adjEmptyCell);
                    }
                });
    }

    public Integer bombsAmount() {
        return cells.stream().map(c -> c.isBomb() ? 1 : 0).reduce(0, Integer::sum);
    }

    public Cell getCell(int x, int y) {
        return cells.stream().filter(c -> c.getPositionX() == x && c.getPositionY() == y).findFirst()
                .orElseThrow(() -> new MineException(REQUEST_CELL_IS_OUT));
    }

    public void flagCell(Cell cell) {
        if(!this.getStatus().equals(StatusEnum.GAME_ACTIVE)){
            throw new MineException(COULD_NOT_DO_MOVE);
        }
        cell.flag();
    }

    private void acumulateTipoPaused() {
        Calendar initDate = Calendar.getInstance();
        initDate.setTime(this.lastUpdate != null ? this.lastUpdate : this.creationTime);
        Calendar endDate = Calendar.getInstance();
        endDate.setTime(new Date());
        long diffSeconds = (endDate.getTimeInMillis() - initDate.getTimeInMillis()) / 1000;
        this.timePaused = this.timePaused + diffSeconds;
    }

    public Game recognizeCell(Cell cell) {
        if(!this.getStatus().equals(StatusEnum.GAME_ACTIVE)){
            throw new MineException(COULD_NOT_DO_MOVE);
        }
        cell.setRecognized(true);

        if (cell.isBomb()) {
            this.setStatus(StatusEnum.FINAL);
            return this;
        }

        if (cell.getValue() == 0) {
            this.recognizeAdjacentCells(cell);
        }

        int totalRecognized = cells.stream().map(c -> c.isRecognized() ? 1 : 0).reduce(0, Integer::sum);
        int totalBombs = bombsAmount();

        if (totalRecognized + totalBombs == cells.size()) {
            this.setStatus(StatusEnum.WINNER);
        }

        return this;
    }

}